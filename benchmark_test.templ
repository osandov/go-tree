package tree

// Benchmark tree implementations.
// vim: ft=go

import (
	"math/rand"
	"testing"
)

func createBalancedTree(tree Tree, n, m int) {
	if n >= m {
		return
	}

	mid := (n + m) / 2
	tree.Set(Uint64Key(mid), mid)
	createBalancedTree(tree, n, mid)
	createBalancedTree(tree, mid+1, n)
}

func TestBalancedTree(t *testing.T) {
	tree := NewBST()
	createBalancedTree(tree, 0, NUM_NODES)
}

// Benchmark implementations.

func benchmarkCreateBalanced(b *testing.B, tree Tree) {
	for i := 0; i < b.N; i++ {
		createBalancedTree(tree, 0, NUM_NODES)
	}
}

func benchmarkCreateRandom(b *testing.B, tree Tree) {
	for i := 0; i < b.N / NUM_NODES; i++ {
		for j := 0; j < NUM_NODES; j++ {
			x := uint64(rand.Int())
			tree.Set(Uint64Key(x), x)
		}
	}
}

func benchmarkRandomGet(b *testing.B, tree Tree) {
	createBalancedTree(tree, 0, NUM_NODES)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		tree.Get(Uint64Key(rand.Intn(NUM_NODES)))
	}
}

func benchmarkLocalGet(b *testing.B, tree Tree) {
	createBalancedTree(tree, 0, NUM_NODES)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for j := 5; j < NUM_NODES - 5; j++ {
			x := j + rand.Intn(10) - 5
			tree.Get(Uint64Key(x))
		}
	}
}

func benchmarkRandomDel(b *testing.B, tree Tree) {
	createBalancedTree(tree, 0, NUM_NODES)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		x := rand.Intn(NUM_NODES)
		tree.Del(Uint64Key(x))
		tree.Set(Uint64Key(x), x)
	}
}

func benchmarkLocalDel(b *testing.B, tree Tree) {
	createBalancedTree(tree, 0, NUM_NODES)
	b.ResetTimer()
	for i := 0; i < b.N / NUM_NODES; i++ {
		for j := 5; j < NUM_NODES - 5; j++ {
			for k := 0; k < 10; k++ {
				x := j + rand.Intn(10) - 5
				tree.Del(Uint64Key(x))
				tree.Set(Uint64Key(x), x)
			}
		}
	}
}

// TEST: Binary search tree: BST: NewBST()

// TEST: Splay tree: Splay: NewSplay()

// TEST: Simple trie: SimpleTrie: NewTreeFromTrie(NewTrie())

// TEST: CLZ trie: CLZTrie: NewTreeFromTrie(NewCLZTrie())
